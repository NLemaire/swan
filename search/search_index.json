{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Le code SWAN Pr\u00e9sentation Cette documentation a pour objectif de permettre une bonne compr\u00e9hension du code swan d\u00e9velopp\u00e9 en langage NabLab . Elle doit permettre \u00e9galement de faciliter l'utilisation et la modification de celui-ci. Le code swan est le r\u00e9sultat d'un stage de M1 r\u00e9alis\u00e9 au CEA . Le probl\u00e8me physique Le code de simulation de propagation d'ondes swan est bas\u00e9 sur des \u00e9quations SHALLOW WATER . Le mod\u00e8le utilis\u00e9 est tir\u00e9 du chapitre 2 du livre intitul\u00e9 NUMERICAL MODELING OF WATER WAVES de Charles L. Mader. Le lecteur int\u00e9ress\u00e9 peut lire ce chapitre afin de comprendre le raisonnement menant au syst\u00e8me d'\u00e9quations aux d\u00e9riv\u00e9es partielles suivant : \\[ \\begin{align} \\frac{\\partial U_x}{\\partial t} + U_x \\frac{\\partial U_x}{\\partial x} + U_y \\frac{\\partial U_x}{\\partial y} + g \\frac{\\partial H}{\\partial x} = FU_y + F^{(x)} - g \\frac{U_x(U^2_x + U^2_y)^{1/2}}{C^2(D+H-R)} \\end{align} \\] \\[ \\begin{align} \\frac{\\partial U_y}{\\partial t} + U_x \\frac{\\partial U_y}{\\partial x} + U_y \\frac{\\partial U_y}{\\partial y} + g \\frac{\\partial H}{\\partial y} = -FU_x + F^{(y)} - g \\frac{U_y(U^2_x + U^2_y)^{1/2}}{C^2(D+H-R)} \\end{align} \\] \\[ \\begin{align} \\frac{\\partial H}{\\partial t} + \\frac{\\partial (D+H-R)U_x}{\\partial x} + \\frac{\\partial (D+H-R)U_y}{\\partial y} - \\frac{\\partial R}{\\partial t} = 0 \\end{align} \\] \\(U_x\\) : vitesse dans la direction x (indice i), \\(U_x\\) devient \\(U\\) dans les \u00e9quations discr\u00e9tis\u00e9es \\(U_y\\) : vitesse dans la direction y (indice j), \\(U_y\\) devient \\(V\\) dans les \u00e9quations discr\u00e9tis\u00e9es \\(g\\) : acc\u00e9l\u00e9ration de la gravit\u00e9 ( \\(-9.8\\) \\(m.s^{-2}\\) ) \\(t\\) : temps \\(H\\) : hauteur d'eau au dessus de la surface au repos \\(R\\) : mouvement du sol \\(F\\) : param\u00e8tre de Coriolis \\(C\\) : coefficient de De Chezy \\(F^{(x)}, F^{(y)}\\) : Fonctions de for\u00e7age \\(D\\) : profondeur Le sch\u00e9ma num\u00e9rique Vous trouverez ci-dessous le sch\u00e9ma num\u00e9rique impl\u00e9ment\u00e9, ainsi qu'une illustration d'une maille. Cette derni\u00e8re montre comment sont organis\u00e9es les donn\u00e9es sur le maillage. \\[ \\begin{align} H^{n+1}_{i,j} = H^n_{i,j} - \\Delta t \\Biggl[ \\frac{U^n_{i+1,j}}{\\Delta x}(TD1) - \\frac{U^n_{i,j}}{\\Delta x}(TD2) + \\frac{V^n_{i,j+1}}{\\Delta y}(TV1) - \\frac{V^n_{i,j}}{\\Delta y}(TV2)\\Biggr] + R^{n+1}_{i,j} - R^{n}_{i,j} \\end{align} \\] \\[ \\begin{align} TD1 &amp = D_{i+1,j} + H^n_{i+1,j} - R^n_{i+1,j} &amp (U^n_{i+1,j} \\lt 0) \\\\ TD1 &amp = D_{i,j} + H^n_{i,j} - R^n_{i,j} &amp (U^n_{i+1,j} \\gt 0) \\\\ TD2 &amp = D_{i,j} + H^n_{i,j} - R^n_{i,j} &amp (U^n_{i,j} \\lt 0) \\\\ TD2 &amp = D_{i-1,j} + H^n_{i-1,j} - R^n_{i-1,j} &amp (U^n_{i,j} \\gt 0) \\\\ TV1 &amp = D_{i,j+1} + H^n_{i,j+1} - R^n_{i,j+1} &amp (V^n_{i,j+1} \\lt 0) \\\\ TV1 &amp = D_{i,j} + H^n_{i,j} - R^n_{i,j} &amp (V^n_{i,j+1} \\gt 0) \\\\ TV2 &amp = D_{i,j} + H^n_{i,j} - R^n_{i,j} &amp (V^n_{i,j} \\lt 0) \\\\ TV2 &amp = D_{i,j-1} + H^n_{i,j-1} - R^n_{i,j-1} &amp (V^n_{i,j} \\gt 0) \\\\ \\end{align} \\] \\[ \\begin{align} U^{n+1}_{i,j} = U^n_{i,j} - \\Delta t \\Biggl[\\frac{U^n_{i,j}}{\\Delta x}(TU1) + \\frac{TV}{\\Delta y}(TU2)\\Biggr] - g \\frac{\\Delta t}{\\Delta x}\\Bigl[THU\\Bigr] + \\Delta t \\Bigl[-FV^n_{i,j} - F^{(x)}_{i,j} + S^B_{i,j}\\Bigr] \\end{align} \\] \\[ \\begin{align} TV &amp = 0.25 * (V^n_{i,j} + V^n_{i,j+1} + V^n_{i-1,j+1} + V^n_{i-1,j} ) \\\\ TU1 &amp = U^n_{i+1,j} - U^n_{i,j} &amp (U^n_{i,j} \\lt 0)\\\\ TU1 &amp = U^n_{i,j} - U^n_{i-1,j} &amp (U^n_{i,j} \\gt 0)\\\\ TU2 &amp = U^n_{i,j+1} - U^n_{i,j} &amp (TV \\lt 0)\\\\ TU2 &amp = U^n_{i,j} - U^n_{i,j-1} &amp (TV \\gt 0)\\\\ THU &amp = H^n_{i,j} - H^n_{i,j-1} &amp \\\\ S^B_{i,j} &amp = gU^n_{i,j}\\frac{\\Biggl[(U^n_{i,j})^2 + (V^n_{i,j})^2\\Biggr]^{1/2}}{C^2(D_{i,j})+H^n_{i,j}}\\\\ \\end{align} \\] \\[ \\begin{align} V^{n+1}_{i,j} = V^n_{i,j} - \\Delta t \\Biggl[\\frac{TU}{\\Delta x}(TV1) + \\frac{V^n_{i,j}}{\\Delta y}(TV2)\\Biggr] - g \\frac{\\Delta t}{\\Delta y}\\Bigl[THV\\Bigr] + \\Delta t \\Bigl[-FU^n_{i,j} - F^{(y)}_{i,j} + S^B_{i,j}\\Bigr] \\end{align} \\] \\[ \\begin{align} TU &amp = 0.25 * (U^n_{i,j} + U^n_{i,j+1} + U^n_{i-1,j+1} + U^n_{i-1,j} ) \\\\ TV1 &amp = V^n_{i+1,j} - V^n_{i,j} &amp (U^n_{i,j} \\lt 0)\\\\ TV1 &amp = V^n_{i,j} - V^n_{i-1,j} &amp (U^n_{i,j} \\gt 0)\\\\ TV2 &amp = V^n_{i,j+1} - V^n_{i,j} &amp (TV \\lt 0)\\\\ TV2 &amp = V^n_{i,j} - V^n_{i,j-1} &amp (TV \\gt 0)\\\\ THV &amp = H^n_{i,j} - H^n_{i,j-1} &amp \\\\ S^B_{i,j} &amp = gU^n_{i,j}\\frac{\\Biggl[(U^n_{i,j})^2 + (V^n_{i,j})^2\\Biggr]^{1/2}}{C^2(D_{i,j})+H^n_{i,j}}\\\\ \\end{align} \\] Le graphe du programme La biblioth\u00e8que BathyLib Comme dans beaucoup de programme, l'initialisation des variables n\u00e9cessaires \u00e0 la simulation requiert la lecture de donn\u00e9es depuis des fichiers. Dans notre cas, nous sommes amen\u00e9s \u00e0 lire des fichiers avec extension .nc ou .grd , qui sont des fichiers au format NetCDF . Il est possible d'inspecter manuellement le contenu d'un fichier en utilisant le programme ncdump ou d'utiliser une librairie afin d'extraire les donn\u00e9es. C'est cette derni\u00e8re possibilit\u00e9 qu'utilise notre code. Ci-dessous une image montrant l'organisation des donn\u00e9es au sein d'un fichier .grd. Les fonctions de lecture de fichiers .grd se trouvent dans l'extension NabLab nomm\u00e9e BathyLib . Pour comprendre comment fonctionne cette extension, consultez la documentation NabLab . La seule diff\u00e9rence est que dans le tutoriel NabLab, l'extension est un projet externe alors que dans le code swan c'est simplement un sous-r\u00e9pertoire de src . Les fonctions de BathyLib s'ex\u00e9cutent obligatoirement de mani\u00e8re s\u00e9quentielle (toutes les fonctions externes de NabLab). Dans le cas du code SWAN, les fonctions sont toutes des fonctions de lecture de fichier. Les fichiers .grd sont utilis\u00e9s pour initialiser les variables vivant sur les mailles (H, D, R, latitude, longitude). Lorsque l'utilisateur \u00e9crit quelque chose comme \\(\\forall ic \\in innerCells()\\) dans un fichier source NabLab (fichier .n ), cela sera traduit en une boucle sur toutes les innerCells . L'ordre de parcours des mailles se fait ligne par ligne, du bas vers le haut. Les valeurs des grandeurs d'int\u00e9r\u00eat stock\u00e9es dans les fichiers sont ordonn\u00e9es de la m\u00eame fa\u00e7on. Les fonctions de lecture ne font donc que r\u00e9cup\u00e9rer les donn\u00e9es dans un tableau, puis renvoient les valeurs une par une. \u00c0 chaque appel, un compteur, qui est l'indice de la prochaine valeur \u00e0 renvoyer, est incr\u00e9ment\u00e9. Dans le cas des longitudes et latitudes, leur fonction externe respective doit proc\u00e9der \u00e0 une \u00e9tape suppl\u00e9mentaire entre la lecture et la cr\u00e9ation du tableau de donn\u00e9es. Cette derni\u00e8re information n'int\u00e9ressera que les personnes voulant comprendre le code des fonctions externes ou voulant modifier ces derni\u00e8res. Un utilisateur doit seulement retenir que les variables stock\u00e9es sur chaque maille se remplissent ligne par ligne, du bas vers le haut. Il doit \u00e9galement se souvenir que le maillage utilis\u00e9 contient un \"bord artificiel\" servant \u00e0 imposer des conditions au bord. Les fichiers .grd contiennent uniquement les valeurs des innerCells . Nous verrons par la suite que la taille du maillage est donn\u00e9e au programme par un fichier de donn\u00e9es utilisateur. Cette taille prend en compte le bord artificiel. Ci-dessous une illustration expliquant comment la librairie NetCDF est utilis\u00e9e dans le code des fonctions externes. Les singletons Vous remarquez que le code comporte beaucoup de \\(\\forall qqchose \\in unensemble\\) . Ces expressions sont g\u00e9n\u00e9ralement transcrites comme des boucles sur chacun des \u00e9l\u00e9ments de unensemble . Dans notre cas, il faut voir \u00e7a uniquement comme un point de syntaxe \u00e0 connaitre. En effet, dans le code SWAN, les ensembles sont souvent des singletons. Nous pouvons donc voir ces expressions comme des d\u00e9finitions. Par exemple \\(\\forall rc \\in rightCell(c)\\) peut \u00eatre vu comme: \"soit rc la cellule \u00e0 droite de c\" car rightCell(c) est un singleton. L'initialisation des variables Lors de la lecture du code, vous remarquerez que l'initialisation se fait \u00e0 l'aide d'une \"astuce\". En effet, souvenons nous que nous avons autour du vrai maillage, un \"bord artificiel\". Celui-ci est constitu\u00e9 de mailles et de faces que l'on doit mettre \u00e0 jour \u00e0 chaque pas de temps. Chaque maille et face du bord du maillage, va \u00eatre initialis\u00e9e en allant chercher les valeurs de son plus proche voisin contenu dans le \"vrai\" maillage. Il n'est pas possible d'imposer d'ordonnancement avec le langage NabLab: par exemple initialiser d'abord l'int\u00e9rieur, puis les bords au temps t=0. Nous devons donc utiliser deux variables, H et Hini afin d'initialiser, au temps \\(t_0\\) , la variable H. Nous remplissons d'abord l'int\u00e9rieur du maillage \u00e0 l'aide de Hini, puis nous clonons les valeurs sur le bord, avant de recopier dans H, les valeurs de Hini. Si nous ne faisons pas cela, NabLab va d\u00e9tecter un cycle, et refusera de g\u00e9n\u00e9rer du code. Utilisation du programme L'utilisation des programmes Swan et Swangeo est grandement simplifi\u00e9s gr\u00e2ce aux capacit\u00e9s de NabLab. Apr\u00e8s compilation des sources, le programme s'ex\u00e9cute comme suit : ./swan path/to/options.json L'int\u00e9gralit\u00e9 des informations \u00e0 fournir au programme doit \u00eatre \u00e9crite dans ce fichier d'options utilisateur au format Json . Nous allons d\u00e9tailler son contenu et expliquer bri\u00e8vement le r\u00f4le de chacun des champs du fichier. Les probl\u00e8mes d'affichage Pour l'affichage des r\u00e9sultats nous utilison le logiciel Paraview . Des probl\u00e8mes d'affichage peuvent survenir. G\u00e9n\u00e9ralement, cela signifie que les valeurs contenues dans les fichiers de r\u00e9sultats sont \u00e9gales \u00e0 Inf, nan, -nan, etc. Lorsque cela se produit, Paraview peut soit afficher du jaune, soit ne plus rien afficher du tout, soit indiquer un message d'erreur comme \"can't read value at ...\". Cela se produit notamment si le pas de temps et le pas d'espace ne v\u00e9rifient pas la condition CFL. Il vous faudra alors soit r\u00e9duire le pas de temps de la simulation, soit augmenter les pas d'espace. Nous tenons \u00e0 faire remarquer que dans le cas du code SWAN, la condition CFL nous indique que le pas de temps doit v\u00e9rifier : \\[ \\delta t \\lt \\frac{0.3}{200} \\delta x \\] Pour un pas \\(\\delta x = 3000\\) m\u00e8tres, \\(\\delta t = 5s\\) devrait \u00eatre suffisant. Nous avons remarqu\u00e9 que la simulation ne fonctionne plus si \\(\\delta t \\gt 0.1 s\\) . Ce comportement reste \u00e0 ce jour inexpliqu\u00e9. La g\u00e9n\u00e9ration de code L'environnement de d\u00e9veloppement NabLab, outre le fait de permettre l'\u00e9dition d'un code source, permet de g\u00e9n\u00e9rer un code en langage g\u00e9n\u00e9raliste, compilable ou interpr\u00e9table. Nous avons choisi comme cible de g\u00e9n\u00e9ration du code C++ multi-threads, parall\u00e9lisme en m\u00e9moire partag\u00e9e (cible StlThread ). Ce choix s'effectue dans le fichier .ngen . Note D'autres choix de g\u00e9n\u00e9ration sont possibles. Voir la documentation NabLab pour plus d'informations. Dans ce projet, nous avons choisi d'utiliser cette cible de g\u00e9n\u00e9ration pour des raisons de portabilit\u00e9. En effet, c'est le seul backend ne n\u00e9cessitant pas d'installer de librairie externe. Nous verrons dans la partie suivante, que nous avons tout de m\u00eame utilis\u00e9 du C++ Multithread Kokkos pour faire des tests de scalabilit\u00e9s.","title":"Le code Swan"},{"location":"#le-code-swan","text":"","title":"Le code SWAN"},{"location":"#presentation","text":"Cette documentation a pour objectif de permettre une bonne compr\u00e9hension du code swan d\u00e9velopp\u00e9 en langage NabLab . Elle doit permettre \u00e9galement de faciliter l'utilisation et la modification de celui-ci. Le code swan est le r\u00e9sultat d'un stage de M1 r\u00e9alis\u00e9 au CEA .","title":"Pr\u00e9sentation"},{"location":"#le-probleme-physique","text":"Le code de simulation de propagation d'ondes swan est bas\u00e9 sur des \u00e9quations SHALLOW WATER . Le mod\u00e8le utilis\u00e9 est tir\u00e9 du chapitre 2 du livre intitul\u00e9 NUMERICAL MODELING OF WATER WAVES de Charles L. Mader. Le lecteur int\u00e9ress\u00e9 peut lire ce chapitre afin de comprendre le raisonnement menant au syst\u00e8me d'\u00e9quations aux d\u00e9riv\u00e9es partielles suivant : \\[ \\begin{align} \\frac{\\partial U_x}{\\partial t} + U_x \\frac{\\partial U_x}{\\partial x} + U_y \\frac{\\partial U_x}{\\partial y} + g \\frac{\\partial H}{\\partial x} = FU_y + F^{(x)} - g \\frac{U_x(U^2_x + U^2_y)^{1/2}}{C^2(D+H-R)} \\end{align} \\] \\[ \\begin{align} \\frac{\\partial U_y}{\\partial t} + U_x \\frac{\\partial U_y}{\\partial x} + U_y \\frac{\\partial U_y}{\\partial y} + g \\frac{\\partial H}{\\partial y} = -FU_x + F^{(y)} - g \\frac{U_y(U^2_x + U^2_y)^{1/2}}{C^2(D+H-R)} \\end{align} \\] \\[ \\begin{align} \\frac{\\partial H}{\\partial t} + \\frac{\\partial (D+H-R)U_x}{\\partial x} + \\frac{\\partial (D+H-R)U_y}{\\partial y} - \\frac{\\partial R}{\\partial t} = 0 \\end{align} \\] \\(U_x\\) : vitesse dans la direction x (indice i), \\(U_x\\) devient \\(U\\) dans les \u00e9quations discr\u00e9tis\u00e9es \\(U_y\\) : vitesse dans la direction y (indice j), \\(U_y\\) devient \\(V\\) dans les \u00e9quations discr\u00e9tis\u00e9es \\(g\\) : acc\u00e9l\u00e9ration de la gravit\u00e9 ( \\(-9.8\\) \\(m.s^{-2}\\) ) \\(t\\) : temps \\(H\\) : hauteur d'eau au dessus de la surface au repos \\(R\\) : mouvement du sol \\(F\\) : param\u00e8tre de Coriolis \\(C\\) : coefficient de De Chezy \\(F^{(x)}, F^{(y)}\\) : Fonctions de for\u00e7age \\(D\\) : profondeur","title":"Le probl\u00e8me physique"},{"location":"#le-schema-numerique","text":"Vous trouverez ci-dessous le sch\u00e9ma num\u00e9rique impl\u00e9ment\u00e9, ainsi qu'une illustration d'une maille. Cette derni\u00e8re montre comment sont organis\u00e9es les donn\u00e9es sur le maillage. \\[ \\begin{align} H^{n+1}_{i,j} = H^n_{i,j} - \\Delta t \\Biggl[ \\frac{U^n_{i+1,j}}{\\Delta x}(TD1) - \\frac{U^n_{i,j}}{\\Delta x}(TD2) + \\frac{V^n_{i,j+1}}{\\Delta y}(TV1) - \\frac{V^n_{i,j}}{\\Delta y}(TV2)\\Biggr] + R^{n+1}_{i,j} - R^{n}_{i,j} \\end{align} \\] \\[ \\begin{align} TD1 &amp = D_{i+1,j} + H^n_{i+1,j} - R^n_{i+1,j} &amp (U^n_{i+1,j} \\lt 0) \\\\ TD1 &amp = D_{i,j} + H^n_{i,j} - R^n_{i,j} &amp (U^n_{i+1,j} \\gt 0) \\\\ TD2 &amp = D_{i,j} + H^n_{i,j} - R^n_{i,j} &amp (U^n_{i,j} \\lt 0) \\\\ TD2 &amp = D_{i-1,j} + H^n_{i-1,j} - R^n_{i-1,j} &amp (U^n_{i,j} \\gt 0) \\\\ TV1 &amp = D_{i,j+1} + H^n_{i,j+1} - R^n_{i,j+1} &amp (V^n_{i,j+1} \\lt 0) \\\\ TV1 &amp = D_{i,j} + H^n_{i,j} - R^n_{i,j} &amp (V^n_{i,j+1} \\gt 0) \\\\ TV2 &amp = D_{i,j} + H^n_{i,j} - R^n_{i,j} &amp (V^n_{i,j} \\lt 0) \\\\ TV2 &amp = D_{i,j-1} + H^n_{i,j-1} - R^n_{i,j-1} &amp (V^n_{i,j} \\gt 0) \\\\ \\end{align} \\] \\[ \\begin{align} U^{n+1}_{i,j} = U^n_{i,j} - \\Delta t \\Biggl[\\frac{U^n_{i,j}}{\\Delta x}(TU1) + \\frac{TV}{\\Delta y}(TU2)\\Biggr] - g \\frac{\\Delta t}{\\Delta x}\\Bigl[THU\\Bigr] + \\Delta t \\Bigl[-FV^n_{i,j} - F^{(x)}_{i,j} + S^B_{i,j}\\Bigr] \\end{align} \\] \\[ \\begin{align} TV &amp = 0.25 * (V^n_{i,j} + V^n_{i,j+1} + V^n_{i-1,j+1} + V^n_{i-1,j} ) \\\\ TU1 &amp = U^n_{i+1,j} - U^n_{i,j} &amp (U^n_{i,j} \\lt 0)\\\\ TU1 &amp = U^n_{i,j} - U^n_{i-1,j} &amp (U^n_{i,j} \\gt 0)\\\\ TU2 &amp = U^n_{i,j+1} - U^n_{i,j} &amp (TV \\lt 0)\\\\ TU2 &amp = U^n_{i,j} - U^n_{i,j-1} &amp (TV \\gt 0)\\\\ THU &amp = H^n_{i,j} - H^n_{i,j-1} &amp \\\\ S^B_{i,j} &amp = gU^n_{i,j}\\frac{\\Biggl[(U^n_{i,j})^2 + (V^n_{i,j})^2\\Biggr]^{1/2}}{C^2(D_{i,j})+H^n_{i,j}}\\\\ \\end{align} \\] \\[ \\begin{align} V^{n+1}_{i,j} = V^n_{i,j} - \\Delta t \\Biggl[\\frac{TU}{\\Delta x}(TV1) + \\frac{V^n_{i,j}}{\\Delta y}(TV2)\\Biggr] - g \\frac{\\Delta t}{\\Delta y}\\Bigl[THV\\Bigr] + \\Delta t \\Bigl[-FU^n_{i,j} - F^{(y)}_{i,j} + S^B_{i,j}\\Bigr] \\end{align} \\] \\[ \\begin{align} TU &amp = 0.25 * (U^n_{i,j} + U^n_{i,j+1} + U^n_{i-1,j+1} + U^n_{i-1,j} ) \\\\ TV1 &amp = V^n_{i+1,j} - V^n_{i,j} &amp (U^n_{i,j} \\lt 0)\\\\ TV1 &amp = V^n_{i,j} - V^n_{i-1,j} &amp (U^n_{i,j} \\gt 0)\\\\ TV2 &amp = V^n_{i,j+1} - V^n_{i,j} &amp (TV \\lt 0)\\\\ TV2 &amp = V^n_{i,j} - V^n_{i,j-1} &amp (TV \\gt 0)\\\\ THV &amp = H^n_{i,j} - H^n_{i,j-1} &amp \\\\ S^B_{i,j} &amp = gU^n_{i,j}\\frac{\\Biggl[(U^n_{i,j})^2 + (V^n_{i,j})^2\\Biggr]^{1/2}}{C^2(D_{i,j})+H^n_{i,j}}\\\\ \\end{align} \\]","title":"Le sch\u00e9ma num\u00e9rique"},{"location":"#le-graphe-du-programme","text":"","title":"Le graphe du programme"},{"location":"#la-bibliotheque-bathylib","text":"Comme dans beaucoup de programme, l'initialisation des variables n\u00e9cessaires \u00e0 la simulation requiert la lecture de donn\u00e9es depuis des fichiers. Dans notre cas, nous sommes amen\u00e9s \u00e0 lire des fichiers avec extension .nc ou .grd , qui sont des fichiers au format NetCDF . Il est possible d'inspecter manuellement le contenu d'un fichier en utilisant le programme ncdump ou d'utiliser une librairie afin d'extraire les donn\u00e9es. C'est cette derni\u00e8re possibilit\u00e9 qu'utilise notre code. Ci-dessous une image montrant l'organisation des donn\u00e9es au sein d'un fichier .grd. Les fonctions de lecture de fichiers .grd se trouvent dans l'extension NabLab nomm\u00e9e BathyLib . Pour comprendre comment fonctionne cette extension, consultez la documentation NabLab . La seule diff\u00e9rence est que dans le tutoriel NabLab, l'extension est un projet externe alors que dans le code swan c'est simplement un sous-r\u00e9pertoire de src . Les fonctions de BathyLib s'ex\u00e9cutent obligatoirement de mani\u00e8re s\u00e9quentielle (toutes les fonctions externes de NabLab). Dans le cas du code SWAN, les fonctions sont toutes des fonctions de lecture de fichier. Les fichiers .grd sont utilis\u00e9s pour initialiser les variables vivant sur les mailles (H, D, R, latitude, longitude). Lorsque l'utilisateur \u00e9crit quelque chose comme \\(\\forall ic \\in innerCells()\\) dans un fichier source NabLab (fichier .n ), cela sera traduit en une boucle sur toutes les innerCells . L'ordre de parcours des mailles se fait ligne par ligne, du bas vers le haut. Les valeurs des grandeurs d'int\u00e9r\u00eat stock\u00e9es dans les fichiers sont ordonn\u00e9es de la m\u00eame fa\u00e7on. Les fonctions de lecture ne font donc que r\u00e9cup\u00e9rer les donn\u00e9es dans un tableau, puis renvoient les valeurs une par une. \u00c0 chaque appel, un compteur, qui est l'indice de la prochaine valeur \u00e0 renvoyer, est incr\u00e9ment\u00e9. Dans le cas des longitudes et latitudes, leur fonction externe respective doit proc\u00e9der \u00e0 une \u00e9tape suppl\u00e9mentaire entre la lecture et la cr\u00e9ation du tableau de donn\u00e9es. Cette derni\u00e8re information n'int\u00e9ressera que les personnes voulant comprendre le code des fonctions externes ou voulant modifier ces derni\u00e8res. Un utilisateur doit seulement retenir que les variables stock\u00e9es sur chaque maille se remplissent ligne par ligne, du bas vers le haut. Il doit \u00e9galement se souvenir que le maillage utilis\u00e9 contient un \"bord artificiel\" servant \u00e0 imposer des conditions au bord. Les fichiers .grd contiennent uniquement les valeurs des innerCells . Nous verrons par la suite que la taille du maillage est donn\u00e9e au programme par un fichier de donn\u00e9es utilisateur. Cette taille prend en compte le bord artificiel. Ci-dessous une illustration expliquant comment la librairie NetCDF est utilis\u00e9e dans le code des fonctions externes.","title":"La biblioth\u00e8que BathyLib"},{"location":"#les-singletons","text":"Vous remarquez que le code comporte beaucoup de \\(\\forall qqchose \\in unensemble\\) . Ces expressions sont g\u00e9n\u00e9ralement transcrites comme des boucles sur chacun des \u00e9l\u00e9ments de unensemble . Dans notre cas, il faut voir \u00e7a uniquement comme un point de syntaxe \u00e0 connaitre. En effet, dans le code SWAN, les ensembles sont souvent des singletons. Nous pouvons donc voir ces expressions comme des d\u00e9finitions. Par exemple \\(\\forall rc \\in rightCell(c)\\) peut \u00eatre vu comme: \"soit rc la cellule \u00e0 droite de c\" car rightCell(c) est un singleton.","title":"Les singletons"},{"location":"#linitialisation-des-variables","text":"Lors de la lecture du code, vous remarquerez que l'initialisation se fait \u00e0 l'aide d'une \"astuce\". En effet, souvenons nous que nous avons autour du vrai maillage, un \"bord artificiel\". Celui-ci est constitu\u00e9 de mailles et de faces que l'on doit mettre \u00e0 jour \u00e0 chaque pas de temps. Chaque maille et face du bord du maillage, va \u00eatre initialis\u00e9e en allant chercher les valeurs de son plus proche voisin contenu dans le \"vrai\" maillage. Il n'est pas possible d'imposer d'ordonnancement avec le langage NabLab: par exemple initialiser d'abord l'int\u00e9rieur, puis les bords au temps t=0. Nous devons donc utiliser deux variables, H et Hini afin d'initialiser, au temps \\(t_0\\) , la variable H. Nous remplissons d'abord l'int\u00e9rieur du maillage \u00e0 l'aide de Hini, puis nous clonons les valeurs sur le bord, avant de recopier dans H, les valeurs de Hini. Si nous ne faisons pas cela, NabLab va d\u00e9tecter un cycle, et refusera de g\u00e9n\u00e9rer du code.","title":"L'initialisation des variables"},{"location":"#utilisation-du-programme","text":"L'utilisation des programmes Swan et Swangeo est grandement simplifi\u00e9s gr\u00e2ce aux capacit\u00e9s de NabLab. Apr\u00e8s compilation des sources, le programme s'ex\u00e9cute comme suit : ./swan path/to/options.json L'int\u00e9gralit\u00e9 des informations \u00e0 fournir au programme doit \u00eatre \u00e9crite dans ce fichier d'options utilisateur au format Json . Nous allons d\u00e9tailler son contenu et expliquer bri\u00e8vement le r\u00f4le de chacun des champs du fichier.","title":"Utilisation du programme"},{"location":"#les-problemes-daffichage","text":"Pour l'affichage des r\u00e9sultats nous utilison le logiciel Paraview . Des probl\u00e8mes d'affichage peuvent survenir. G\u00e9n\u00e9ralement, cela signifie que les valeurs contenues dans les fichiers de r\u00e9sultats sont \u00e9gales \u00e0 Inf, nan, -nan, etc. Lorsque cela se produit, Paraview peut soit afficher du jaune, soit ne plus rien afficher du tout, soit indiquer un message d'erreur comme \"can't read value at ...\". Cela se produit notamment si le pas de temps et le pas d'espace ne v\u00e9rifient pas la condition CFL. Il vous faudra alors soit r\u00e9duire le pas de temps de la simulation, soit augmenter les pas d'espace. Nous tenons \u00e0 faire remarquer que dans le cas du code SWAN, la condition CFL nous indique que le pas de temps doit v\u00e9rifier : \\[ \\delta t \\lt \\frac{0.3}{200} \\delta x \\] Pour un pas \\(\\delta x = 3000\\) m\u00e8tres, \\(\\delta t = 5s\\) devrait \u00eatre suffisant. Nous avons remarqu\u00e9 que la simulation ne fonctionne plus si \\(\\delta t \\gt 0.1 s\\) . Ce comportement reste \u00e0 ce jour inexpliqu\u00e9.","title":"Les probl\u00e8mes d'affichage"},{"location":"#la-generation-de-code","text":"L'environnement de d\u00e9veloppement NabLab, outre le fait de permettre l'\u00e9dition d'un code source, permet de g\u00e9n\u00e9rer un code en langage g\u00e9n\u00e9raliste, compilable ou interpr\u00e9table. Nous avons choisi comme cible de g\u00e9n\u00e9ration du code C++ multi-threads, parall\u00e9lisme en m\u00e9moire partag\u00e9e (cible StlThread ). Ce choix s'effectue dans le fichier .ngen . Note D'autres choix de g\u00e9n\u00e9ration sont possibles. Voir la documentation NabLab pour plus d'informations. Dans ce projet, nous avons choisi d'utiliser cette cible de g\u00e9n\u00e9ration pour des raisons de portabilit\u00e9. En effet, c'est le seul backend ne n\u00e9cessitant pas d'installer de librairie externe. Nous verrons dans la partie suivante, que nous avons tout de m\u00eame utilis\u00e9 du C++ Multithread Kokkos pour faire des tests de scalabilit\u00e9s.","title":"La g\u00e9n\u00e9ration de code"},{"location":"filetree/","text":"Arborescence des fichiers Nous allons dans cette partie expliquer l'organisation du projet en diff\u00e9rents r\u00e9pertoires. Nous d\u00e9taillerons le contenu de chacun de ceux-ci. Note Nous verrons des dossiers appel\u00e9s swan et swangeo , En effet, le code SWAN est disponible en deux versions l\u00e9g\u00e8rement diff\u00e9rentes: swan prend en param\u00e8tre des fichiers .grd en coordonn\u00e9es CARTESIENNES. swangeo prend en param\u00e8tre des fichiers .grd en coordonn\u00e9es GEOGRAPHIQUES. Les fichiers sources en langage NabLab sont quasiment identiques, le sch\u00e9ma num\u00e9rique est lui exactement identique. La diff\u00e9rence est que les pas d'espace sont les m\u00eames pour toutes les mailles du maillage dans swan , et d\u00e9pendent du couple (latitude / longitude) dans swangeo . Liste des r\u00e9pertoires: META-INF : contient un fichier d'information \u00e0 destination de NabLab. data : jeux de donn\u00e9es swan : bathym\u00e9tries et surfaces d'eau en coordonn\u00e9es CARTESIENNES, au format .grd (.nc), \u00e0 n'utiliser qu'avec le programme swan . swangeo : idem pour swangeo . src-gen-cpp/stl-thread : le r\u00e9pertoire de g\u00e9n\u00e9ration C++ swan : fichiers du code source C++ du programme swan et fichier CMakeLists.txt pour la compilation. swangeo : iden pour swangeo . src-gen : r\u00e9pertoire de g\u00e9n\u00e9ration Json et TeX swan : contient un fichier Swan.tex , une repr\u00e9sentation du fichier source Swan.n sous forme de fichier LaTeX, ainsi qu'un exemple de fichier Json. swangeo : idem pour swangeo src : r\u00e9pertoire des fichiers de code source de l'utilisateur bathylib : contient les fichiers BathyLib.n et BathyLib.ngen qui d\u00e9finissent respectivement l'extension BathyLib et le provider C++ de l'extension swan : contient le fichier de code source Swan.n et le fichier de configuration de la g\u00e9n\u00e9ration de l'application Swan.ngen swangeo : idem pour swangeo usecases : r\u00e9pertoire contenant les cas tests swan : jeux de donn\u00e9es au format .json , destin\u00e9s \u00e0 \u00eatre personnalis\u00e9s par l'utilisateur. Nous rappelons que ces fichiers sont \u00e0 donner en argument du programme swan uniquement. squareGaussCases : jeux de donn\u00e9es au format .json , ainsi qu'une vid\u00e9o par cas test montrant le r\u00e9sultat que l'on obtient apr\u00e8s simulation, en utilisant le fichier json en question. Le contenu de ce sous dossier n'est pas destin\u00e9 \u00e0 \u00eatre modifi\u00e9 par l'utilisateur. swangeo : jeux de donn\u00e9es au format .json , destin\u00e9s \u00e0 \u00eatre personnalis\u00e9s par l'utilisateur. Nous rappelons que ces fichiers sont \u00e0 donner en argument du programme swangeo uniquement. mediterrCases : jeux de donn\u00e9es au format .json , ainsi qu'une vid\u00e9o par cas test montrant le r\u00e9sultat que l'on obtient apr\u00e8s simulation, en utilisant le fichier json en question. Ces cas tests concernent le tsunami provoqu\u00e9 par le s\u00e9isme de Boumerdes, 2003. Le contenu de ce sous dossier n'est pas destin\u00e9 \u00e0 \u00eatre modifi\u00e9 par l'utilisateur.","title":"Arborescence des fichiers"},{"location":"filetree/#arborescence-des-fichiers","text":"Nous allons dans cette partie expliquer l'organisation du projet en diff\u00e9rents r\u00e9pertoires. Nous d\u00e9taillerons le contenu de chacun de ceux-ci. Note Nous verrons des dossiers appel\u00e9s swan et swangeo , En effet, le code SWAN est disponible en deux versions l\u00e9g\u00e8rement diff\u00e9rentes: swan prend en param\u00e8tre des fichiers .grd en coordonn\u00e9es CARTESIENNES. swangeo prend en param\u00e8tre des fichiers .grd en coordonn\u00e9es GEOGRAPHIQUES. Les fichiers sources en langage NabLab sont quasiment identiques, le sch\u00e9ma num\u00e9rique est lui exactement identique. La diff\u00e9rence est que les pas d'espace sont les m\u00eames pour toutes les mailles du maillage dans swan , et d\u00e9pendent du couple (latitude / longitude) dans swangeo . Liste des r\u00e9pertoires: META-INF : contient un fichier d'information \u00e0 destination de NabLab. data : jeux de donn\u00e9es swan : bathym\u00e9tries et surfaces d'eau en coordonn\u00e9es CARTESIENNES, au format .grd (.nc), \u00e0 n'utiliser qu'avec le programme swan . swangeo : idem pour swangeo . src-gen-cpp/stl-thread : le r\u00e9pertoire de g\u00e9n\u00e9ration C++ swan : fichiers du code source C++ du programme swan et fichier CMakeLists.txt pour la compilation. swangeo : iden pour swangeo . src-gen : r\u00e9pertoire de g\u00e9n\u00e9ration Json et TeX swan : contient un fichier Swan.tex , une repr\u00e9sentation du fichier source Swan.n sous forme de fichier LaTeX, ainsi qu'un exemple de fichier Json. swangeo : idem pour swangeo src : r\u00e9pertoire des fichiers de code source de l'utilisateur bathylib : contient les fichiers BathyLib.n et BathyLib.ngen qui d\u00e9finissent respectivement l'extension BathyLib et le provider C++ de l'extension swan : contient le fichier de code source Swan.n et le fichier de configuration de la g\u00e9n\u00e9ration de l'application Swan.ngen swangeo : idem pour swangeo usecases : r\u00e9pertoire contenant les cas tests swan : jeux de donn\u00e9es au format .json , destin\u00e9s \u00e0 \u00eatre personnalis\u00e9s par l'utilisateur. Nous rappelons que ces fichiers sont \u00e0 donner en argument du programme swan uniquement. squareGaussCases : jeux de donn\u00e9es au format .json , ainsi qu'une vid\u00e9o par cas test montrant le r\u00e9sultat que l'on obtient apr\u00e8s simulation, en utilisant le fichier json en question. Le contenu de ce sous dossier n'est pas destin\u00e9 \u00e0 \u00eatre modifi\u00e9 par l'utilisateur. swangeo : jeux de donn\u00e9es au format .json , destin\u00e9s \u00e0 \u00eatre personnalis\u00e9s par l'utilisateur. Nous rappelons que ces fichiers sont \u00e0 donner en argument du programme swangeo uniquement. mediterrCases : jeux de donn\u00e9es au format .json , ainsi qu'une vid\u00e9o par cas test montrant le r\u00e9sultat que l'on obtient apr\u00e8s simulation, en utilisant le fichier json en question. Ces cas tests concernent le tsunami provoqu\u00e9 par le s\u00e9isme de Boumerdes, 2003. Le contenu de ce sous dossier n'est pas destin\u00e9 \u00e0 \u00eatre modifi\u00e9 par l'utilisateur.","title":"Arborescence des fichiers"},{"location":"results/","text":"Performances et r\u00e9sultats R\u00e9sultats obtenus Dans cette section, nous discutons des r\u00e9sultats obtenus, que ce soit des performances en elles-m\u00eames, ou que ce soit de la coh\u00e9rence de la simulation avec les pr\u00e9dictions faites en 2003 par le CEA. Nous commen\u00e7ons par analyser les r\u00e9sultats de la simulation, puis nous finissons par les mesures de performances qui ont \u00e9t\u00e9 effectu\u00e9es. Vous trouverez ci-dessous les r\u00e9sultats de la propagation du tsunami de Boumerdes calcul\u00e9s par le programme swangeo et les r\u00e9sultats de r\u00e9f\u00e9rence calcul\u00e9 par le CEA en 2003 Ces derni\u00e8res donn\u00e9es sont les dur\u00e9es minimales th\u00e9oriques d'arriv\u00e9es. Nous pouvons remarquer que la valeur calcul\u00e9e par swangeo au niveau de la ville de Leucate (ville repr\u00e9sent\u00e9e la plus \u00e0 gauche) n'est pas coh\u00e9rente avec les donn\u00e9es de r\u00e9f\u00e9rence. Nous n'avons pas d'explication pour cela pour l'instant. Concernant la ville de Fos-sur-mer, nous avons calcul\u00e9 un temps d'arriv\u00e9e de 95 minutes alors que la r\u00e9f\u00e9rence est de 120 minutes. Bien que cel\u00e0 soit coh\u00e9rent (95 < 120), la diff\u00e9rence reste assez importante. Pour toutes les autres villes, les temps d'arriv\u00e9es calcul\u00e9s sont en ad\u00e9quation avec les donn\u00e9es de r\u00e9f\u00e9rence. De plus, la forme de la premi\u00e8re vague correspond bien \u00e0 celle de la vague de r\u00e9f\u00e9rence. Temps de r\u00e9f\u00e9rence d'arriv\u00e9e du Tsunami Temps d'arriv\u00e9e du Tsunami calcul\u00e9 avec SwanGeo Performances Regardons maintenant les mesures de performances qui ont \u00e9t\u00e9 effectu\u00e9s. Nous n'avons trait\u00e9 que les codes g\u00e9n\u00e9r\u00e9s avec les backends C++ Multithread STL et C++ Multithread Kokkos. Nous avons \u00e9tudier les propri\u00e9t\u00e9s de scalabilit\u00e9 forte. Les mesures ont \u00e9t\u00e9 faites sur le programme swan avec un cas test canal disponible dans le r\u00e9pertoire usecases . La version test\u00e9e \u00e9tait encore en d\u00e9veloppement aux moments des mesures, mais les algorithmes effectuant la quasi totalit\u00e9 des calculs \u00e9taient d\u00e9j\u00e0 impl\u00e9ment\u00e9s. Scalabilit\u00e9 forte Pour \u00e9tudier la scalabilit\u00e9 forte, il faut doubler la puissance de calcul. Ici on double le nombre de processeurs en conservant la taille du probl\u00e8me constante (taille du maillage). Dans l'id\u00e9al, en doublant le nombre de processeurs, le temps de calcul devrait \u00eatre divis\u00e9 par deux. Ce r\u00e9sultat est th\u00e9orique, en pratique, le gain de temps est beaucoup moins \u00e9lev\u00e9. Le but est seulement de s'approcher le plus possible d'un facteur deux. Nous avons \u00e9tudi\u00e9 la scalabilit\u00e9 forte en faisant varier le pas d'\u00e9criture. Cela nous a permis de prouver que ce pas \u00e9tait un facteur limitant. Nous avons \u00e9galement \u00e9tudi\u00e9 la scalabilit\u00e9 forte, en fonction de la taille du maillage pour le backend C++ Multithread STL. Sur les 3 graphes ci-dessus, lorsque la taille du maillage n'est pas pr\u00e9cis\u00e9e, celle-ci est de 50 000 mailles. Nous pensons que c'est ce qui explique le fait que les dur\u00e9es d'ex\u00e9cution en fonction du nombre de processeurs utilis\u00e9 sont relativement constantes, pour un pas d'\u00e9criture donn\u00e9. La cr\u00e9ation des threads est co\u00fbteuse et masque tout possible gain de performance. Sur le premier graphe, le pas d'\u00e9criture est pris suffisamment grand pour qu'il n'ait quasiment aucun impact sur le temps de calcul. Ce graphe nous montre bien qu'un gain de performance est pr\u00e9sent d\u00e8s que la taille du maillage augmente. Nous remarquons qu'avec 32 coeurs, les performances se d\u00e9gradent un peu. Les points correspondant semblent aberrants. Il s'agit sans doute d'un probl\u00e8me provoqu\u00e9 par la machine de test. Travaux \u00e0 mener Nous pensons qu'il serait int\u00e9ressant de tester les performances sur une machine disposant de GPU, en utilisant le backend de parall\u00e9lisation KokkosTeamThread. Faire des tests de scalabilit\u00e9 faible en faisant varier le pas d'\u00e9criture pourrait \u00e9galement donner des r\u00e9sultats int\u00e9ressants. La version C++ Multithread STL, lib\u00e9r\u00e9 du facteur limitant qu'est le pas d'\u00e9criture, n'a pas montr\u00e9 de propri\u00e9t\u00e9s de scalabilit\u00e9 forte. Nous nous attendons \u00e0 ce qu'il en soit de m\u00eame pour la scalabilit\u00e9 faible. Cependant, la version C++ Multithread Kokkos a montr\u00e9 une certaine scalabilit\u00e9 forte, quoiqu'imparfaite, laissant penser qu'il y a une certaine scalabilit\u00e9 faible gr\u00e2ce \u00e0 Kokkos. Nous invitons le lecteur \u00e0 s'int\u00e9resser aux courbes pr\u00e9sentes ci-dessus pour en savoir un peu plus.","title":"Performances et r\u00e9sultats"},{"location":"results/#performances-et-resultats","text":"","title":"Performances et r\u00e9sultats"},{"location":"results/#resultats-obtenus","text":"Dans cette section, nous discutons des r\u00e9sultats obtenus, que ce soit des performances en elles-m\u00eames, ou que ce soit de la coh\u00e9rence de la simulation avec les pr\u00e9dictions faites en 2003 par le CEA. Nous commen\u00e7ons par analyser les r\u00e9sultats de la simulation, puis nous finissons par les mesures de performances qui ont \u00e9t\u00e9 effectu\u00e9es. Vous trouverez ci-dessous les r\u00e9sultats de la propagation du tsunami de Boumerdes calcul\u00e9s par le programme swangeo et les r\u00e9sultats de r\u00e9f\u00e9rence calcul\u00e9 par le CEA en 2003 Ces derni\u00e8res donn\u00e9es sont les dur\u00e9es minimales th\u00e9oriques d'arriv\u00e9es. Nous pouvons remarquer que la valeur calcul\u00e9e par swangeo au niveau de la ville de Leucate (ville repr\u00e9sent\u00e9e la plus \u00e0 gauche) n'est pas coh\u00e9rente avec les donn\u00e9es de r\u00e9f\u00e9rence. Nous n'avons pas d'explication pour cela pour l'instant. Concernant la ville de Fos-sur-mer, nous avons calcul\u00e9 un temps d'arriv\u00e9e de 95 minutes alors que la r\u00e9f\u00e9rence est de 120 minutes. Bien que cel\u00e0 soit coh\u00e9rent (95 < 120), la diff\u00e9rence reste assez importante. Pour toutes les autres villes, les temps d'arriv\u00e9es calcul\u00e9s sont en ad\u00e9quation avec les donn\u00e9es de r\u00e9f\u00e9rence. De plus, la forme de la premi\u00e8re vague correspond bien \u00e0 celle de la vague de r\u00e9f\u00e9rence.","title":"R\u00e9sultats obtenus"},{"location":"results/#temps-de-reference-darrivee-du-tsunami","text":"","title":"Temps de r\u00e9f\u00e9rence d'arriv\u00e9e du Tsunami"},{"location":"results/#temps-darrivee-du-tsunami-calcule-avec-swangeo","text":"","title":"Temps d'arriv\u00e9e du Tsunami calcul\u00e9 avec SwanGeo"},{"location":"results/#performances","text":"Regardons maintenant les mesures de performances qui ont \u00e9t\u00e9 effectu\u00e9s. Nous n'avons trait\u00e9 que les codes g\u00e9n\u00e9r\u00e9s avec les backends C++ Multithread STL et C++ Multithread Kokkos. Nous avons \u00e9tudier les propri\u00e9t\u00e9s de scalabilit\u00e9 forte. Les mesures ont \u00e9t\u00e9 faites sur le programme swan avec un cas test canal disponible dans le r\u00e9pertoire usecases . La version test\u00e9e \u00e9tait encore en d\u00e9veloppement aux moments des mesures, mais les algorithmes effectuant la quasi totalit\u00e9 des calculs \u00e9taient d\u00e9j\u00e0 impl\u00e9ment\u00e9s.","title":"Performances"},{"location":"results/#scalabilite-forte","text":"Pour \u00e9tudier la scalabilit\u00e9 forte, il faut doubler la puissance de calcul. Ici on double le nombre de processeurs en conservant la taille du probl\u00e8me constante (taille du maillage). Dans l'id\u00e9al, en doublant le nombre de processeurs, le temps de calcul devrait \u00eatre divis\u00e9 par deux. Ce r\u00e9sultat est th\u00e9orique, en pratique, le gain de temps est beaucoup moins \u00e9lev\u00e9. Le but est seulement de s'approcher le plus possible d'un facteur deux. Nous avons \u00e9tudi\u00e9 la scalabilit\u00e9 forte en faisant varier le pas d'\u00e9criture. Cela nous a permis de prouver que ce pas \u00e9tait un facteur limitant. Nous avons \u00e9galement \u00e9tudi\u00e9 la scalabilit\u00e9 forte, en fonction de la taille du maillage pour le backend C++ Multithread STL. Sur les 3 graphes ci-dessus, lorsque la taille du maillage n'est pas pr\u00e9cis\u00e9e, celle-ci est de 50 000 mailles. Nous pensons que c'est ce qui explique le fait que les dur\u00e9es d'ex\u00e9cution en fonction du nombre de processeurs utilis\u00e9 sont relativement constantes, pour un pas d'\u00e9criture donn\u00e9. La cr\u00e9ation des threads est co\u00fbteuse et masque tout possible gain de performance. Sur le premier graphe, le pas d'\u00e9criture est pris suffisamment grand pour qu'il n'ait quasiment aucun impact sur le temps de calcul. Ce graphe nous montre bien qu'un gain de performance est pr\u00e9sent d\u00e8s que la taille du maillage augmente. Nous remarquons qu'avec 32 coeurs, les performances se d\u00e9gradent un peu. Les points correspondant semblent aberrants. Il s'agit sans doute d'un probl\u00e8me provoqu\u00e9 par la machine de test.","title":"Scalabilit\u00e9 forte"},{"location":"results/#travaux-a-mener","text":"Nous pensons qu'il serait int\u00e9ressant de tester les performances sur une machine disposant de GPU, en utilisant le backend de parall\u00e9lisation KokkosTeamThread. Faire des tests de scalabilit\u00e9 faible en faisant varier le pas d'\u00e9criture pourrait \u00e9galement donner des r\u00e9sultats int\u00e9ressants. La version C++ Multithread STL, lib\u00e9r\u00e9 du facteur limitant qu'est le pas d'\u00e9criture, n'a pas montr\u00e9 de propri\u00e9t\u00e9s de scalabilit\u00e9 forte. Nous nous attendons \u00e0 ce qu'il en soit de m\u00eame pour la scalabilit\u00e9 faible. Cependant, la version C++ Multithread Kokkos a montr\u00e9 une certaine scalabilit\u00e9 forte, quoiqu'imparfaite, laissant penser qu'il y a une certaine scalabilit\u00e9 faible gr\u00e2ce \u00e0 Kokkos. Nous invitons le lecteur \u00e0 s'int\u00e9resser aux courbes pr\u00e9sentes ci-dessus pour en savoir un peu plus.","title":"Travaux \u00e0 mener"}]}