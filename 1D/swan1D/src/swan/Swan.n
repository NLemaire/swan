module Swan;

with Math.*;
with BathyLib.*;

itemtypes { node, cell , face}

// nodes collection
connectivity nodes: → {node};
connectivity nodesOfCell: cell → {node};

// faces collection
connectivity faces: → {face};
connectivity innerFaces: → {face};
connectivity InnerVerticalFaces: → {face};
connectivity InnerHorizontalFaces: → {face};

// cells collection
connectivity cells: → {cell};
connectivity innerCells: → {cell};
connectivity topCells: → {cell};
connectivity bottomCells: → {cell};
connectivity leftCells: → {cell};
connectivity rightCells: → {cell};

// cell related collection
connectivity rightFaceOfCell: cell → face;
connectivity leftFaceOfCell : cell → face;
connectivity topFaceOfCell : cell → face;
connectivity bottomFaceOfCell: cell → face;
connectivity rightCell: cell → cell;
connectivity leftCell: cell → cell;
connectivity topCell: cell → cell;
connectivity bottomCell: cell → cell;

// face related collection
connectivity backCell: face → cell;
connectivity frontCell: face → cell;
connectivity bottomFaceNeighbour: face → face;
connectivity bottomLeftFaceNeighbour: face → face;
connectivity bottomRightFaceNeighbour: face → face;
connectivity topFaceNeighbour: face → face;
connectivity topLeftFaceNeighbour: face → face;
connectivity topRightFaceNeighbour: face → face;
connectivity rightFaceNeighbour: face → face;
connectivity leftFaceNeighbour: face → face;

// options
option ℝ X_EDGE_LENGTH = 20.0;
option ℝ Y_EDGE_LENGTH = 20.0;
option ℾ DConst = true;
option ℝ Dini = -1000.0;
option ℝ δt = 0.008;
option ℝ F = 0.0; // Coriolis parameter
option ℕ maxIter = 5000000;
option ℝ stopTime = 20.0;

option ℝ X0 = 50.0;
option ℝ Amp = 0.1;

let ℝ δx = X_EDGE_LENGTH;
let ℝ δy = Y_EDGE_LENGTH;
let ℝ g = -9.8; // -9.8
let ℝ C = 40.0; // De Chezy coefficient, C ∈ [20, 80]
let ℝ Sigma=5000.0;

ℝ center{cells};
ℝ t;
ℝ[2] X{nodes};

ℝ U{faces}; // velocity in x direction
ℝ Uini{faces}; 

ℝ H{cells}; // wave height above mean water level
ℝ Hini{cells}; //

 
ℝ Dijini{cells}; // depth ( < 0)
ℝ Dij{cells}; // depth ( < 0)



iterate n while (t^{n+1} < stopTime && n < maxIter);

InitTime: t^{n=0} = 0.0;



// depth initialization
InitDijini: ∀ic∈innerCells(), Dijini{ic} = Dini;


InitDij:
{
	∀tc∈topCells(),    ∀bc∈bottomCell(tc), Dij{tc} = Dijini{bc};
	∀bc∈bottomCells(), ∀tc∈topCell(bc), Dij{bc} = Dijini{tc}; 
	∀lc∈leftCells(),   ∀rc∈rightCell(lc), Dij{lc} = Dijini{rc}; 
	∀rc∈rightCells(),  ∀lc∈leftCell(rc), Dij{rc} = Dijini{lc};
	∀ic∈innerCells(),  Dij{ic} = Dijini{ic}; 
}





IniCenter: ∀j∈innerCells(), center{j} = dot ((0.25 * ∑{r∈nodesOfCell(j)}(X{r})),[1.0,0.0]);



// wave initialization 
InitHini: ∀ic∈innerCells(),
{
	Hini{ic} =Amp * exp(-0.5* (center{ic}-X0)*(center{ic}-X0)/(Sigma*Sigma)) ;
}

// trick to initialize Boundary Condition on H
InitH:
{
	∀t∈topCells(), ∀bt∈bottomCell(t), H^{n=0}{t} = Hini{bt};
	∀b∈bottomCells(), ∀tb∈topCell(b), H^{n=0}{b} = Hini{tb};
	∀l∈leftCells(), ∀rl∈rightCell(l), H^{n=0}{l} = Hini{rl};
	∀r∈rightCells(), ∀lr∈leftCell(r), H^{n=0}{r} = Hini{lr};
	∀ic∈innerCells(), H^{n=0}{ic} = Hini{ic};
}

// x velocity initialization
InitUini: ∀f∈innerFaces(), Uini{f} = 0.0;

// trick to initialize Boundary Condition on U
InitU:
{
	∀tc∈topCells(), ∀rf∈rightFaceOfCell(tc), ∀bc∈bottomCell(tc), ∀brf∈rightFaceOfCell(bc),
		U^{n=0}{rf} = Uini{brf};
	∀bc∈bottomCells(), ∀rf∈rightFaceOfCell(bc), ∀tc∈topCell(bc), ∀trf∈rightFaceOfCell(tc),
		U^{n=0}{rf} = Uini{trf};
	∀lc∈leftCells(), ∀lf∈leftFaceOfCell(lc), ∀rf∈rightFaceOfCell(lc),
		U^{n=0}{lf} = Uini{rf};
	∀rc∈rightCells(), ∀rf∈rightFaceOfCell(rc), ∀lf∈leftFaceOfCell(rc),
		U^{n=0}{rf} = Uini{lf};
}



// compute new wave height using the numerical schema 
UpdateHinner:∀ic∈innerCells(), 
{
	let ℝ TD1 = 0.0;
	let ℝ TD2 = 0.0;

	
	// computeTD1;
	∀ rf ∈ rightFaceOfCell(ic),
		if (U^{n}{rf} < 0)
			∀ rc ∈ rightCell(ic),
				TD1 = Dij{rc} + H^{n}{rc};
		else
			TD1 = Dij{ic} + H^{n}{ic} ;

	// computeTD2;
	∀ lf ∈ leftFaceOfCell(ic),
		if( U^{n}{lf} < 0)
			TD2 = Dij{ic} + H^{n}{ic};
		else
			∀ lc ∈ leftCell(ic),
				TD2 = Dij{lc} + H^{n}{lc};

	

	// computeH^{n+1}
	∀rf∈rightFaceOfCell(ic), ∀lf∈leftFaceOfCell(ic), 
		H^{n+1}{ic} = H^{n}{ic} - δt/(δx)*(U^{n}{rf} * TD1  - U^{n}{lf} * TD2);
}

// update boundary condition for wave height
UpdateHouter:  
{
	∀tc∈topCells(), ∀bc∈bottomCell(tc),
		H^{n+1}{tc} = H^{n}{bc};
	∀bc∈bottomCells(), ∀tc∈topCell(bc),
		H^{n+1}{bc} = H^{n}{tc};
	∀lc∈leftCells(), ∀rc∈rightCell(lc),
		H^{n+1}{lc} = H^{n}{rc};
	∀rc∈rightCells(), ∀lc∈leftCell(rc),
		H^{n+1}{rc} = H^{n}{lc};
}

// compute new x velocity using the numerical schema
UpdateUinner:∀ic∈innerCells(),∀rfc∈rightFaceOfCell(ic),
{
	
	let ℝ TU1 = 0.0;
	

	// compute TU1
	if(U^{n}{rfc} < 0)
		∀icp∈rightCell(ic), ∀rfcp∈rightFaceOfCell(icp),
			TU1  = U^{n}{rfcp} -U^{n}{rfc};
	else
		∀icm∈leftCell(ic), ∀lfcm∈leftFaceOfCell(icm),
			TU1 = U^{n}{rfc} - U^{n}{lfcm};


	// compute U^{n+1}
	∀icp∈rightCell(ic),
		U^{n+1}{rfc} = U^{n}{rfc} - δt/ δx * (U^{n}{rfc} * TU1  + g * (H^{n}{icp} - H^{n}{ic}) ) ;
}

// update boundary condition for x velocity
UpdateUouter:
{
	∀tc∈topCells(), ∀rf∈rightFaceOfCell(tc), ∀bc∈bottomCell(tc), ∀brf∈rightFaceOfCell(bc),
		U^{n+1}{rf} = U^{n}{brf};
	∀bc∈bottomCells(), ∀rf∈rightFaceOfCell(bc), ∀bcf∈topCell(bc), ∀trf∈rightFaceOfCell(bcf),
		U^{n+1}{rf} = U^{n}{trf};
	∀lc∈leftCells(), ∀lf∈leftFaceOfCell(lc), ∀rf∈rightFaceOfCell(lc),
		U^{n+1}{lf} = U^{n}{rf};
	∀rc∈rightCells(), ∀rf∈rightFaceOfCell(rc), ∀lf∈leftFaceOfCell(rc),
		U^{n+1}{rf} = U^{n}{lf};
}


ComputeTn: t^{n+1} = t^{n} + δt;
